<div id="loader">
    <h2>جاري تحميل محرك السحر...</h2>
    <p>يرجى السماح للكاميرا للتحكم في الكون</p>
</div>

<div id="cam-wrapper">
    <canvas id="cam-preview"></canvas>
</div>

<div id="status-pill">بانتظار اليد...</div>

<video id="video-input"></video>
<div id="canvas-container"></div>

<!-- مكتبات Three.js و GUI -->
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
        }
    }
</script>

<!-- مكتبات MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import GUI from 'lil-gui';

    // --- الإعدادات الرئيسية ---
    const config = {
        count: 40000,           // عدد الجزيئات (كثافة عالية)
        size: 0.08,             // حجم الجزيء
        shape: 'Spiral Galaxy', // الشكل الافتراضي
        speed: 0.2,             // سرعة الحركة الذاتية
        interactionStrength: 2.0 // قوة تأثير اليد
    };

    // متغيرات النظام
    let scene, camera, renderer, particles, geometry, material;
    let controls;
    let clock = new THREE.Clock();
    
    // متغيرات التحكم باليد
    let handState = {
        x: 0, y: 0,             // موقع اليد (للتدوير والتحريك)
        expansion: 1.0,         // مدى فتح اليد (للتكبير)
        detected: false
    };
    // تنعيم الحركة (Smoothing)
    let targetRotationX = 0;
    let targetRotationY = 0;
    let currentRotationX = 0;
    let currentRotationY = 0;

    initThree();
    initGUI();
    initMediaPipe();
    animate();

    // 1. إعداد بيئة 3D
    function initThree() {
        const container = document.getElementById('canvas-container');
        
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); // ضباب كوني أسود

        camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 12;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        container.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false; // سنستخدم اليد للتقريب
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // خامة الجزيئات السحرية
        const sparkTexture = createMagicTexture();

        material = new THREE.PointsMaterial({
            size: config.size,
            map: sparkTexture,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending, // دمج الأضواء
            depthWrite: false,
            vertexColors: true // تفعيل الألوان المتداخلة
        });

        generateShape(config.shape);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // 2. محرك توليد الأشكال السحرية
    function generateShape(type) {
        if (particles) scene.remove(particles);

        const positions = [];
        const colors = [];
        const color1 = new THREE.Color();
        const color2 = new THREE.Color();
        const count = config.count;

        for (let i = 0; i < count; i++) {
            let x, y, z;
            let r, g, b; // الألوان

            if (type === 'Spiral Galaxy') {
                // مجرة حلزونية بأذرع متعددة
                const branches = 5;
                const spinRadius = Math.random() * 8;
                const branchAngle = (i % branches) * ((Math.PI * 2) / branches);
                const curve = spinRadius * 0.8; // انحناء
                
                const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);
                const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 0.5;
                const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);

                x = Math.cos(branchAngle + curve) * spinRadius + randomX;
                y = randomY;
                z = Math.sin(branchAngle + curve) * spinRadius + randomZ;

                // تلوين: المركز ذهبي، الأطراف أزرق وبنفسجي
                const mix = spinRadius / 8;
                color1.setHSL(0.6, 1.0, 0.5); // أزرق
                color2.setHSL(0.9, 1.0, 0.6); // وردي/بنفسجي
                color1.lerp(color2, Math.random()); // خلط عشوائي
                if(spinRadius < 1.5) color1.setHSL(0.1, 1.0, 0.8); // مركز ذهبي
            } 
            else if (type === 'Saturn Rings') {
                // كوكب بحلقات
                const r = Math.random();
                if (r > 0.3) { // الحلقات
                    const ang = Math.random() * Math.PI * 2;
                    const dist = 4 + Math.random() * 4;
                    x = Math.cos(ang) * dist;
                    z = Math.sin(ang) * dist;
                    y = (Math.random() - 0.5) * 0.2;
                    // ألوان الحلقات (قوس قزح باهت)
                    color1.setHSL(dist/10, 0.8, 0.6); 
                } else { // الكوكب نفسه
                    const rad = 2.5;
                    const phi = Math.acos(-1 + (2 * Math.random()));
                    const theta = Math.sqrt(count * Math.PI) * phi;
                    x = rad * Math.cos(theta) * Math.sin(phi);
                    y = rad * Math.sin(theta) * Math.sin(phi);
                    z = rad * Math.cos(phi);
                    // ألوان الكوكب
                    color1.setHSL(0.05 + Math.random()*0.1, 1.0, 0.5); // برتقالي ناري
                }
            }
            else if (type === 'Hyper Tunnel') {
                // نفق زمني
                const angle = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 3;
                const length = (Math.random() - 0.5) * 30; // طويل جداً
                
                x = Math.cos(angle) * radius;
                y = Math.sin(angle) * radius;
                z = length;
                
                // لولبة النفق
                x += Math.sin(z * 0.2) * 2;
                y += Math.cos(z * 0.2) * 2;

                // ألوان النيون (أخضر وأزرق)
                color1.setHSL(0.3 + (z/30)*0.2, 1.0, 0.5); 
            }
            else if (type === 'Quantum Core') {
                // كرة طاقة فوضوية
                const r = 5 * Math.random();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
                
                // ألوان كهربائية
                color1.setHSL(0.5 + Math.random()*0.2, 1.0, 0.7); // Cyan & Blue
            }

            colors.push(color1.r, color1.g, color1.b);
            positions.push(x, y, z);
        }

        geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        // حفظ المواقع الأصلية للحركة
        geometry.userData.originalPositions = Float32Array.from(positions);

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    // 3. نسيج الجزيء (Texture)
    function createMagicTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        
        // رسم وهج ناعم
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    }

    // 4. معالجة الفيديو والذكاء الاصطناعي
    function initMediaPipe() {
        const video = document.getElementById('video-input');
        const previewCanvas = document.getElementById('cam-preview');
        const ctx = previewCanvas.getContext('2d');
        const statusPill = document.getElementById('status-pill');

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(results => {
            document.getElementById('loader').style.display = 'none';
            
            // رسم المعاينة
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            ctx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            if (results.multiHandLandmarks.length > 0) {
                handState.detected = true;
                const lm = results.multiHandLandmarks[0];
                drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2});

                // 1. حساب مركز اليد (للتحريك والتدوير)
                // النقطة 9 هي مفصل الاصبع الوسطى (مركز الكف تقريباً)
                const palmX = lm[9].x; 
                const palmY = lm[9].y;
                
                // تحديث الحالة (مع قلب المحور الأفقي لأن الكاميرا مرآة)
                handState.x = (1 - palmX) * 2 - 1; // تحويل من [0,1] إلى [-1,1]
                handState.y = -(palmY * 2 - 1);    // تحويل من [0,1] إلى [-1,1]

                // 2. حساب الانفتاح (للتكبير/التصغير)
                // المسافة بين المعصم (0) ورأس الوسطى (12) مقارنة بحجم الكف (0-5)
                const handSize = Math.hypot(lm[5].x - lm[0].x, lm[5].y - lm[0].y);
                const fingerExtension = Math.hypot(lm[12].x - lm[0].x, lm[12].y - lm[0].y);
                
                let ratio = fingerExtension / handSize;
                // معايرة النسبة: 1.0 (مغلق) -> 2.2 (مفتوح)
                handState.expansion = Math.max(0.1, Math.min(2.5, (ratio - 0.8) * 1.5));

                // تحديث النص
                let action = "";
                if (handState.expansion < 0.5) action = "انكماش (قبضة)";
                else if (handState.expansion > 1.8) action = "تمدد (يد مفتوحة)";
                else action = "تحكم بالدوران";
                
                statusPill.innerHTML = `موقع X: ${handState.x.toFixed(2)} | ${action}`;
                statusPill.style.borderColor = "#00ff00";

            } else {
                handState.detected = false;
                statusPill.innerHTML = "ابحث عن يدك...";
                statusPill.style.borderColor = "rgba(255,255,255,0.1)";
                
                // عودة تدريجية للوضع الطبيعي
                handState.x *= 0.95;
                handState.y *= 0.95;
                handState.expansion = THREE.MathUtils.lerp(handState.expansion, 1.0, 0.05);
            }
        });

        const cameraUtils = new Camera(video, {
            onFrame: async () => await hands.send({image: video}),
            width: 320, height: 240
        });
        cameraUtils.start();
    }

    // 5. حلقة التحريك (Animation Loop)
    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.0005;

        // منطق التفاعل الفيزيائي
        if (handState.detected) {
            // تدوير المجسم بناءً على حركة اليد يميناً ويساراً وفوق وتحت
            // نقوم بضرب القيمة لزيادة حساسية الدوران
            targetRotationY = handState.x * 1.5; 
            targetRotationX = handState.y * 1.5;
            
            // إيقاف الدوران التلقائي عند التحكم اليدوي
            controls.autoRotate = false;
        } else {
            controls.autoRotate = config.speed > 0;
            targetRotationX = 0;
            targetRotationY = 0;
        }

        // تنعيم حركة الدوران (Smooth Interpolation)
        currentRotationX = THREE.MathUtils.lerp(currentRotationX, targetRotationX, 0.1);
        currentRotationY = THREE.MathUtils.lerp(currentRotationY, targetRotationY, 0.1);

        if (particles) {
            // تطبيق الدوران
            particles.rotation.y += 0.002 + (currentRotationY * 0.05);
            particles.rotation.x = currentRotationX * 0.5; // إمالة خفيفة

            // تطبيق التكبير والتصغير
            let scale = THREE.MathUtils.lerp(particles.scale.x, handState.expansion, 0.1);
            particles.scale.setScalar(scale);

            // حركة الجزيئات الداخلية (Warp Effect)
            const positions = particles.geometry.attributes.position.array;
            const originals = particles.geometry.userData.originalPositions;
            
            for(let i=0; i < config.count; i++) {
                const idx = i * 3;
                // معادلة موجية معقدة لتعطي شعور الحياة
                // إذا كانت اليد مفتوحة جداً، الجزيئات تهتز بقوة
                const excitement = (handState.expansion - 1.0) * 0.5;
                
                positions[idx] = originals[idx] + Math.cos(time + originals[idx+1]) * (0.05 + excitement);
                positions[idx+1] = originals[idx+1] + Math.sin(time + originals[idx]) * (0.05 + excitement);
                
                // إذا كان الشكل نفقاً، حرك الجزيئات نحوك
                if (config.shape === 'Hyper Tunnel') {
                    positions[idx+2] += 0.1 + (handState.expansion * 0.2);
                    if (positions[idx+2] > 15) positions[idx+2] = -15; // إعادة تدوير
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        controls.update();
        renderer.render(scene, camera);
    }

    // 6. واجهة التحكم GUI
    function initGUI() {
        const gui = new GUI({ title: 'لوحة التحكم الفضائية' });
        
        gui.add(config, 'shape', ['Spiral Galaxy', 'Saturn Rings', 'Hyper Tunnel', 'Quantum Core'])
           .name('شكل المجرة')
           .onChange(val => generateShape(val));
           
        gui.add(config, 'interactionStrength', 0.1, 5).name('قوة السحر');
        gui.add(config, 'size', 0.01, 0.3).name('حجم النجوم').onChange(v => material.size = v);
        
        // تخصيص التصميم
        gui.domElement.style.right = '20px';
        gui.domElement.style.top = '20px';
        gui.domElement.style.fontFamily = 'Segoe UI';
    }

</script>
